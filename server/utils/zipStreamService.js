const archiver = require("archiver");
const fs = require("fs");
const path = require("path");
const logger = require("./logger");

/**
 * Production-grade ZIP streaming service for multi-file/folder downloads
 * 
 * Features:
 * - On-the-fly ZIP generation (no temp files)
 * - Streaming for memory efficiency
 * - Recursive folder traversal
 * - Directory structure preservation
 * - Client disconnect handling
 * - Progress tracking support
 * - S3-compatible design (stream from storage)
 */

class ZipStreamService {
  /**
   * Create a streaming ZIP archive
   * @param {object} res - Express response object
   * @param {string} zipName - Name for the ZIP file
   * @param {object} options - Options for ZIP creation
   * @returns {object} Archiver instance
   */
  static createZipStream(res, zipName, options = {}) {
    const {
      compressionLevel = 6, // 0-9, where 9 is max compression
      comment = "Generated by MyDrive",
    } = options;

    // Create archiver instance with ZIP format
    const archive = archiver("zip", {
      zlib: { level: compressionLevel }, // Compression level
      comment,
    });

    // Set response headers for ZIP download
    res.setHeader("Content-Type", "application/zip");
    res.setHeader(
      "Content-Disposition",
      `attachment; filename="${encodeURIComponent(zipName)}"`
    );
    res.setHeader("Cache-Control", "no-cache");
    res.setHeader("X-Content-Type-Options", "nosniff");

    // Pipe archive data to response
    archive.pipe(res);

    // Handle warnings (non-blocking errors)
    archive.on("warning", (err) => {
      if (err.code === "ENOENT") {
        logger.warn("ZIP warning: File not found during archiving", {
          error: err.message,
        });
      } else {
        logger.error("ZIP warning: Unexpected warning during archiving", {
          error: err.message,
          code: err.code,
        });
      }
    });

    // Handle critical errors
    archive.on("error", (err) => {
      logger.error("ZIP error: Critical error during archiving", {
        error: err.message,
        stack: err.stack,
      });
      throw err;
    });

    // Log progress (for debugging)
    archive.on("progress", (progress) => {
      logger.debug("ZIP progress", {
        entriesProcessed: progress.entries.processed,
        entriesTotal: progress.entries.total,
        bytesProcessed: progress.fs.processedBytes,
      });
    });

    return archive;
  }

  /**
   * Add a single file to the ZIP archive
   * @param {object} archive - Archiver instance
   * @param {string} filePath - Absolute path to the file
   * @param {string} zipPath - Path within the ZIP archive
   * @param {object} options - Additional options
   * @returns {Promise<void>}
   */
  static async addFileToZip(archive, filePath, zipPath, options = {}) {
    try {
      // Verify file exists
      if (!fs.existsSync(filePath)) {
        logger.warn("File not found, skipping", { filePath, zipPath });
        return;
      }

      const stats = fs.statSync(filePath);

      // Skip if not a regular file
      if (!stats.isFile()) {
        logger.warn("Not a regular file, skipping", { filePath, zipPath });
        return;
      }

      // Create read stream for memory efficiency
      const fileStream = fs.createReadStream(filePath);

      // Handle stream errors
      fileStream.on("error", (err) => {
        logger.error("Error reading file for ZIP", {
          filePath,
          zipPath,
          error: err.message,
        });
      });

      // Add file stream to archive
      archive.append(fileStream, {
        name: zipPath,
        date: stats.mtime, // Preserve modification time
      });

      logger.debug("File added to ZIP", { filePath, zipPath, size: stats.size });
    } catch (error) {
      logger.error("Failed to add file to ZIP", {
        filePath,
        zipPath,
        error: error.message,
      });
      // Don't throw - continue with other files
    }
  }

  /**
   * Add multiple files to ZIP with their relative paths
   * @param {object} archive - Archiver instance
   * @param {Array} files - Array of {path, zipPath} objects
   * @returns {Promise<number>} Number of files successfully added
   */
  static async addMultipleFilesToZip(archive, files) {
    let addedCount = 0;

    for (const file of files) {
      await this.addFileToZip(archive, file.path, file.zipPath);
      addedCount++;
    }

    return addedCount;
  }

  /**
   * Recursively add a directory to ZIP
   * @param {object} archive - Archiver instance
   * @param {string} dirPath - Absolute path to directory
   * @param {string} zipBasePath - Base path within ZIP
   * @returns {Promise<number>} Number of files added
   */
  static async addDirectoryToZip(archive, dirPath, zipBasePath = "") {
    let filesAdded = 0;

    try {
      // Verify directory exists
      if (!fs.existsSync(dirPath)) {
        logger.warn("Directory not found, skipping", { dirPath });
        return 0;
      }

      const stats = fs.statSync(dirPath);
      if (!stats.isDirectory()) {
        logger.warn("Not a directory, skipping", { dirPath });
        return 0;
      }

      // Read directory contents
      const entries = fs.readdirSync(dirPath, { withFileTypes: true });

      for (const entry of entries) {
        const entryPath = path.join(dirPath, entry.name);
        const zipPath = zipBasePath
          ? path.join(zipBasePath, entry.name)
          : entry.name;

        if (entry.isDirectory()) {
          // Recursively add subdirectory
          filesAdded += await this.addDirectoryToZip(
            archive,
            entryPath,
            zipPath
          );
        } else if (entry.isFile()) {
          // Add file
          await this.addFileToZip(archive, entryPath, zipPath);
          filesAdded++;
        }
      }
    } catch (error) {
      logger.error("Error adding directory to ZIP", {
        dirPath,
        zipBasePath,
        error: error.message,
      });
    }

    return filesAdded;
  }

  /**
   * Finalize and close the ZIP archive
   * @param {object} archive - Archiver instance
   * @returns {Promise<void>}
   */
  static async finalizeZip(archive) {
    return new Promise((resolve, reject) => {
      archive.on("finish", () => {
        logger.info("ZIP archive finalized", {
          totalBytes: archive.pointer(),
        });
        resolve();
      });

      archive.on("error", (err) => {
        logger.error("Error finalizing ZIP", { error: err.message });
        reject(err);
      });

      // Finalize the archive (this triggers the 'finish' event)
      archive.finalize();
    });
  }

  /**
   * Handle client disconnect during ZIP streaming
   * @param {object} req - Express request object
   * @param {object} archive - Archiver instance
   * @param {Function} cleanupFn - Optional cleanup function
   */
  static handleClientDisconnect(req, archive, cleanupFn = null) {
    // Detect client disconnect
    req.on("close", () => {
      logger.warn("Client disconnected during ZIP download");

      // Abort archive stream
      if (archive && !archive.destroyed) {
        archive.abort();
        archive.destroy();
      }

      // Run cleanup if provided
      if (cleanupFn && typeof cleanupFn === "function") {
        cleanupFn();
      }
    });
  }

  /**
   * Calculate total size of files to be zipped (for progress tracking)
   * @param {Array} filePaths - Array of file paths
   * @returns {number} Total size in bytes
   */
  static calculateTotalSize(filePaths) {
    let totalSize = 0;

    for (const filePath of filePaths) {
      try {
        if (fs.existsSync(filePath)) {
          const stats = fs.statSync(filePath);
          if (stats.isFile()) {
            totalSize += stats.size;
          } else if (stats.isDirectory()) {
            totalSize += this.getDirectorySize(filePath);
          }
        }
      } catch (error) {
        logger.warn("Failed to calculate size for file", {
          filePath,
          error: error.message,
        });
      }
    }

    return totalSize;
  }

  /**
   * Recursively calculate directory size
   * @param {string} dirPath - Path to directory
   * @returns {number} Total size in bytes
   */
  static getDirectorySize(dirPath) {
    let size = 0;

    try {
      const entries = fs.readdirSync(dirPath, { withFileTypes: true });

      for (const entry of entries) {
        const entryPath = path.join(dirPath, entry.name);

        if (entry.isDirectory()) {
          size += this.getDirectorySize(entryPath);
        } else if (entry.isFile()) {
          const stats = fs.statSync(entryPath);
          size += stats.size;
        }
      }
    } catch (error) {
      logger.warn("Failed to calculate directory size", {
        dirPath,
        error: error.message,
      });
    }

    return size;
  }
}

module.exports = ZipStreamService;
